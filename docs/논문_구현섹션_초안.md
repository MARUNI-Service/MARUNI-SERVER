# MARUNI 시스템 구현

## X-1절. 개발(배포) 환경

### X-1-1. 시스템 아키텍처

본 시스템은 클라이언트-서버 아키텍처를 기반으로 설계되었으며, RESTful API 방식으로 통신한다. 전체 시스템 구성은 [그림 X-1]과 같다.

```
[그림 X-1] MARUNI 시스템 배포 아키텍처
(추후 배포 도식 이미지 삽입 예정)
```

시스템은 크게 다음 4개의 계층으로 구성된다:

1. **프레젠테이션 계층 (Presentation Layer)**: 클라이언트의 HTTP 요청을 처리하고 RESTful API를 제공한다. Swagger/OpenAPI 3.0 기반의 자동 문서화를 지원하여 API 명세를 실시간으로 확인할 수 있다.

2. **애플리케이션 계층 (Application Layer)**: 비즈니스 로직을 조율하고 도메인 간 통신을 관리한다. DTO(Data Transfer Object) 변환 및 트랜잭션 경계를 정의한다.

3. **도메인 계층 (Domain Layer)**: DDD(Domain-Driven Design) 원칙에 따라 핵심 비즈니스 로직을 캡슐화한다. 엔티티, 값 객체, 리포지토리 인터페이스를 포함한다.

4. **인프라스트럭처 계층 (Infrastructure Layer)**: 외부 시스템과의 통합을 담당한다. PostgreSQL 데이터베이스, OpenAI API, Firebase FCM 등과 연동된다.

주요 외부 시스템 연동은 다음과 같다:

- **PostgreSQL**: 사용자 정보, 대화 이력, 알림 이력 등의 영속 데이터를 관리한다.
- **OpenAI GPT-4o**: Spring AI 프레임워크를 통해 자연어 대화 처리 및 응답 생성을 수행한다.
- **Firebase Admin SDK**: 푸시 알림 발송을 위한 인프라를 제공한다(Phase 3 예정).

### X-1-2. 기술 스택

본 시스템의 개발에 사용된 주요 기술 스택은 [표 X-1]과 같다.

| 분류 | 기술 | 버전 | 용도 |
|------|------|------|------|
| 언어 | Java | 21 (LTS) | 백엔드 애플리케이션 개발 |
| 프레임워크 | Spring Boot | 3.5.3 | 웹 애플리케이션 프레임워크 |
| 빌드 도구 | Gradle | 8.x | 의존성 관리 및 빌드 자동화 |
| 데이터베이스 | PostgreSQL | 15+ | 관계형 데이터베이스 |
| ORM | Spring Data JPA | 3.5.x | 객체-관계 매핑 |
| AI 통합 | Spring AI | 1.0.0-M3 | OpenAI API 통합 |
| AI 모델 | OpenAI GPT-4o | - | 자연어 대화 생성 |
| 보안 | Spring Security | 6.x | 인증/인가 |
| 토큰 관리 | JJWT | 0.12.5 | JWT 생성 및 검증 |
| 문서화 | SpringDoc OpenAPI | 2.8.8 | API 명세 자동 생성 |
| 테스트 | JUnit 5 | - | 단위 테스트 |
| 테스트 | Mockito | - | Mock 기반 테스트 |
| 컨테이너 | Docker | - | 애플리케이션 컨테이너화 |

**표 X-1.** MARUNI 시스템 기술 스택

#### 주요 기술 선정 이유

**1) Spring Boot 3.5.x**
- Java 21의 최신 기능(Record, Pattern Matching 등)을 활용할 수 있다.
- Auto-configuration을 통해 개발 생산성을 향상시킨다.
- 풍부한 생태계와 커뮤니티 지원을 받을 수 있다.

**2) OpenAI GPT-4o**
- 자연어 이해 및 생성 능력이 뛰어나 노인과의 자연스러운 대화가 가능하다.
- Spring AI 프레임워크를 통한 간편한 통합을 지원한다.
- 감정 분석을 위한 컨텍스트 이해 능력이 우수하다.

**3) PostgreSQL**
- ACID 트랜잭션을 보장하여 데이터 일관성을 유지한다.
- JSON 타입 지원으로 유연한 데이터 저장이 가능하다.
- 대용량 데이터 처리 및 복잡한 쿼리 성능이 우수하다.

**4) JWT Stateless 인증**
- 서버 측 세션 저장소가 불필요하여 수평 확장이 용이하다.
- 토큰 기반 인증으로 RESTful API 원칙을 준수한다.
- 클라이언트가 토큰을 관리하여 서버 부하를 감소시킨다.

### X-1-3. 개발 환경 설정

#### Docker 기반 컨테이너화

시스템의 개발 및 배포 환경은 Docker와 Docker Compose를 활용하여 컨테이너화하였다. 이를 통해 개발 환경의 일관성을 보장하고, 배포 과정을 단순화하였다.

```yaml
# docker-compose.yml (주요 부분)
version: '3.8'
services:
  postgres:
    image: postgres:15-alpine
    environment:
      POSTGRES_DB: maruni_db
      POSTGRES_USER: ${DB_USERNAME}
      POSTGRES_PASSWORD: ${DB_PASSWORD}
    ports:
      - "5432:5432"
    volumes:
      - postgres_data:/var/lib/postgresql/data

  app:
    build: .
    ports:
      - "8080:8080"
    depends_on:
      - postgres
    env_file:
      - .env
```

#### 환경 변수 관리

시스템은 민감한 정보를 환경 변수로 관리하여 보안을 강화하였다. `.env` 파일을 통해 다음 정보를 설정한다:

- **DB_USERNAME, DB_PASSWORD**: 데이터베이스 접속 정보
- **JWT_SECRET_KEY**: JWT 서명을 위한 비밀 키 (최소 32자)
- **JWT_ACCESS_EXPIRATION**: 액세스 토큰 유효 시간 (1시간 = 3,600,000ms)
- **OPENAI_API_KEY**: OpenAI API 인증 키

#### 빌드 및 배포 프로세스

Gradle을 사용한 빌드 및 배포 프로세스는 다음과 같다:

```bash
# 1. 애플리케이션 빌드
./gradlew clean build

# 2. 테스트 실행
./gradlew test

# 3. Docker 이미지 생성 및 실행
docker-compose up -d

# 4. 로그 확인
docker-compose logs -f app
```

### X-1-4. 아키텍처 패턴

#### DDD(Domain-Driven Design) 계층 구조

본 시스템은 DDD 원칙에 따라 도메인 중심 설계를 적용하였다. 도메인은 업무 복잡도와 의존성에 따라 3개의 계층으로 구성된다[표 X-2].

| 계층 | 도메인 | 역할 |
|------|--------|------|
| Foundation Layer | Member, Auth | 회원 관리 및 인증 기반 제공 |
| Core Service Layer | Conversation, DailyCheck, Guardian | 핵심 비즈니스 로직 수행 |
| Integration Layer | AlertRule, Notification | 도메인 간 통합 및 알림 처리 |

**표 X-2.** DDD 도메인 계층 구조

#### 도메인별 패키지 구조

각 도메인은 DDD의 4계층 아키텍처를 따른다:

```
domain/{도메인명}/
├── presentation/         # 프레젠테이션 계층
│   └── controller/       # REST API 컨트롤러
├── application/          # 애플리케이션 계층
│   ├── service/          # 애플리케이션 서비스
│   ├── dto/              # 데이터 전송 객체
│   └── mapper/           # DTO ↔ Entity 변환
├── domain/               # 도메인 계층
│   ├── entity/           # 엔티티
│   ├── repository/       # 리포지토리 인터페이스
│   └── vo/               # 값 객체
└── infrastructure/       # 인프라스트럭처 계층
    └── (외부 시스템 연동 구현체)
```

#### 의존성 방향

DDD 원칙에 따라 의존성은 항상 상위 계층에서 하위 계층으로 향한다:

- Integration Layer → Core Service Layer, Foundation Layer
- Core Service Layer → Foundation Layer
- Foundation Layer → 외부 의존성 없음

이를 통해 도메인 간 결합도를 낮추고, 각 도메인의 독립성을 보장한다.

---

## X-2절. 주요 구현 기능

본 시스템은 7개의 핵심 도메인으로 구성되며, 각 도메인별 주요 기능은 [표 X-3]과 같다.

| 도메인 | 주요 기능 | 핵심 기술/알고리즘 | REST API 수 | 완성도 |
|--------|----------|-------------------|-------------|--------|
| Conversation | AI 대화 처리<br>감정 분석 | OpenAI GPT-4o<br>키워드 기반 감정 분석 | 3 | 완성 |
| DailyCheck | 정시 안부 메시지 발송<br>자동 재시도 | Spring Scheduler<br>Cron 표현식<br>점진적 지연 재시도 | - | 완성 |
| AlertRule | 이상징후 감지<br>알림 규칙 관리 | 감정 패턴 분석<br>무응답 분석<br>키워드 감지<br>(Strategy Pattern) | 9 | 완성 |
| Notification | 알림 타입 분류<br>알림 이력 관리<br>읽음 상태 관리 | 9종 알림 타입 시스템<br>메타데이터 영속화 | 3 | 완성 |
| Member | 회원 가입/조회<br>회원 정보 관리 | BCrypt 암호화<br>Bean Validation | 5 | 완성 |
| Guardian | 보호자 관계 설정<br>보호자 알림 관리 | 관계 요청/승인/거절<br>알림 설정 관리 | 7 | 완성 |
| Auth | JWT 인증/인가<br>로그인/로그아웃 | Stateless JWT<br>Access Token Only<br>Spring Security | 2 | 완성 |

**표 X-3.** MARUNI 시스템 주요 구현 기능

전체 시스템은 TDD(Test-Driven Development) 방법론을 적용하여 개발되었으며, 각 도메인은 단위 테스트와 통합 테스트를 통해 검증되었다. 총 25개 이상의 REST API를 제공하며, Swagger UI를 통해 실시간으로 API 명세를 확인하고 테스트할 수 있다.

---

## X-3절. 구현 결과

본 절에서는 시스템의 핵심 기능인 AI 대화 시스템, 이상징후 감지 시스템, 안부 메시지 스케줄링, 알림 시스템의 구현 결과를 상세히 기술한다.

### X-3-1. AI 대화 시스템

#### 기능 개요

AI 대화 시스템은 OpenAI GPT-4o 모델을 활용하여 노인 사용자와 자연스러운 대화를 수행한다. 주요 기능은 다음과 같다:

1. **자연어 대화 처리**: Spring AI 프레임워크를 통해 OpenAI GPT-4o API와 연동하여 사용자의 메시지에 대한 자연스러운 응답을 생성한다.

2. **감정 분석**: 키워드 기반 알고리즘을 사용하여 사용자의 메시지에서 감정(긍정/부정/중립)을 분석한다. 분석된 감정 정보는 이상징후 감지 시스템의 입력 데이터로 활용된다.

3. **대화 컨텍스트 관리**: 멀티턴 대화를 지원하기 위해 최근 대화 이력을 메모리에 유지하고, 이를 GPT-4o 모델의 컨텍스트로 전달한다.

#### 실행 화면

```
[그림 X-2] AI 대화 API 요청/응답 예시 (Swagger UI)
(추후 스크린샷 추가 예정)
```

시스템은 `/api/conversations/messages` 엔드포인트를 통해 대화 메시지를 처리한다. 사용자가 메시지를 전송하면 사용자 메시지와 AI 응답이 함께 반환된다.

#### 핵심 구현 코드

```java
@Service
@Transactional(readOnly = true)
@RequiredArgsConstructor
public class SimpleConversationService {

    private final ConversationManager conversationManager;
    private final MessageProcessor messageProcessor;
    private final AlertDetectionService alertDetectionService;
    private final ConversationMapper mapper;

    /**
     * 사용자 메시지 처리 및 AI 응답 생성
     */
    @Transactional
    public ConversationResponseDto processUserMessage(Long memberId, String content) {
        // 1. 활성 대화 조회 또는 생성
        ConversationEntity conversation = conversationManager.findOrCreateActive(memberId);

        // 2. 메시지 처리 및 AI 응답 생성
        MessageExchangeResult result = messageProcessor.processMessage(conversation, content);

        // 3. 키워드 기반 실시간 감지
        detectKeywordInRealtime(result.userMessage(), memberId);

        return mapper.toResponseDto(result);
    }
}
```

`MessageProcessor`는 다음 작업을 순차적으로 수행한다:

1. 사용자 메시지에 대한 감정 분석 수행
2. 대화 컨텍스트를 포함하여 OpenAI API 호출
3. AI 응답과 사용자 메시지를 데이터베이스에 저장
4. 메시지 교환 결과 반환

#### 동작 설명

전체 처리 흐름은 다음과 같다:

```
사용자 메시지 수신
    ↓
활성 대화 세션 조회/생성
    ↓
감정 분석 (키워드 기반)
    ↓
대화 컨텍스트 구성
    ↓
OpenAI GPT-4o API 호출
    ↓
AI 응답 생성 및 저장
    ↓
키워드 기반 이상징후 감지
    ↓
응답 반환 (사용자 메시지 + AI 응답)
```

감정 분석은 사전 정의된 긍정/부정 키워드 리스트를 기반으로 수행된다. 긍정 키워드(좋다, 행복, 즐겁다 등)와 부정 키워드(슬프다, 우울, 외롭다 등)의 출현 빈도를 계산하여 감정을 판단한다.

### X-3-2. 이상징후 감지 시스템

#### 기능 개요

이상징후 감지 시스템은 노인 사용자의 대화 패턴을 분석하여 건강 및 정신적 이상 징후를 조기에 발견한다. Strategy Pattern을 적용하여 3종의 독립적인 분석 알고리즘을 구현하였다:

1. **감정 패턴 분석 (Emotion Pattern Analysis)**: 최근 N일간의 대화에서 부정적 감정의 비율과 연속성을 분석한다. 3일 연속 부정 감정 또는 부정 감정 비율 70% 이상인 경우 HIGH 수준의 경고를 발생시킨다.

2. **무응답 패턴 분석 (No Response Analysis)**: 정기 안부 메시지에 대한 응답률을 모니터링한다. 3일 연속 무응답 또는 응답률 30% 미만인 경우 HIGH 수준의 경고를 발생시킨다.

3. **키워드 감지 (Keyword Detection)**: 대화 내용에서 긴급 키워드(죽고싶다, 자살 등)와 경고 키워드(우울, 외롭다, 힘들다 등)를 실시간으로 감지한다. 긴급 키워드 감지 시 EMERGENCY 수준의 즉시 알림을 발송한다.

#### 실행 화면

```
[그림 X-3] 이상징후 감지 결과 조회 화면
(추후 스크린샷 추가 예정)
```

보호자는 `/api/alert-rules/history` 엔드포인트를 통해 감지된 이상징후 이력을 조회할 수 있다. 각 이력에는 감지 시각, 경고 수준, 감지 내용, 상세 정보가 포함된다.

#### 핵심 구현 코드

Strategy Pattern을 적용하여 각 분석 알고리즘을 독립적인 컴포넌트로 구현하였다:

```java
/**
 * 이상징후 분석기 인터페이스
 */
public interface AnomalyAnalyzer {
    AlertResult analyze(MemberEntity member, AnalysisContext context);
    AlertType getSupportedType();
    boolean supports(AlertType alertType);
}

/**
 * 감정 패턴 분석기 구현체
 */
@Component
@RequiredArgsConstructor
public class EmotionPatternAnalyzer implements AnomalyAnalyzer {

    private final MessageRepository messageRepository;
    private final AlertConfigurationProperties alertConfig;

    @Override
    public AlertResult analyze(MemberEntity member, AnalysisContext context) {
        // 1. 최근 N일간 사용자 메시지 조회
        LocalDateTime startDate = LocalDateTime.now().minusDays(context.getAnalysisDays());
        List<MessageEntity> recentMessages = messageRepository
            .findRecentUserMessagesByMemberId(
                member.getId(),
                MessageType.USER_MESSAGE,
                startDate
            );

        if (recentMessages.isEmpty()) {
            return AlertResult.noAlert();
        }

        // 2. 감정 패턴 분석
        EmotionTrend emotionTrend = calculateEmotionTrend(recentMessages);

        // 3. 위험도 판정
        return evaluateRiskLevel(emotionTrend);
    }

    private EmotionTrend calculateEmotionTrend(List<MessageEntity> messages) {
        // 일별 감정 그룹화
        Map<LocalDate, List<EmotionType>> dailyEmotions = messages.stream()
            .collect(Collectors.groupingBy(
                msg -> msg.getCreatedAt().toLocalDate(),
                Collectors.mapping(MessageEntity::getEmotion, Collectors.toList())
            ));

        // 부정 감정 비율 및 연속성 계산
        long negativeCount = messages.stream()
            .filter(msg -> msg.getEmotion() == EmotionType.NEGATIVE)
            .count();
        double negativeRatio = (double) negativeCount / messages.size();

        int consecutiveNegativeDays = calculateConsecutiveDays(dailyEmotions);

        return new EmotionTrend(negativeRatio, consecutiveNegativeDays);
    }

    private AlertResult evaluateRiskLevel(EmotionTrend trend) {
        // HIGH: 3일 연속 부정 OR 70% 이상 부정
        if (trend.consecutiveDays() >= 3 || trend.negativeRatio() >= 0.7) {
            return AlertResult.alert(
                AlertLevel.HIGH,
                String.format("%d일 연속 부정 감정 감지", trend.consecutiveDays())
            );
        }
        // MEDIUM: 2일 연속 부정 OR 50% 이상 부정
        if (trend.consecutiveDays() >= 2 || trend.negativeRatio() >= 0.5) {
            return AlertResult.alert(
                AlertLevel.MEDIUM,
                String.format("부정 감정 비율 %.0f%%", trend.negativeRatio() * 100)
            );
        }
        return AlertResult.noAlert();
    }
}
```

`AlertAnalysisOrchestrator`는 3개의 분석기를 병렬로 실행하고 결과를 통합한다:

```java
@Service
@RequiredArgsConstructor
public class AlertAnalysisOrchestrator {

    private final List<AnomalyAnalyzer> analyzers;

    public List<AlertResult> detectAllAnomalies(MemberEntity member) {
        AnalysisContext context = new AnalysisContext(7); // 최근 7일 분석

        return analyzers.stream()
            .map(analyzer -> analyzer.analyze(member, context))
            .filter(AlertResult::isDetected)
            .collect(Collectors.toList());
    }
}
```

#### 동작 설명

전체 처리 흐름은 다음과 같다:

```
대화 메시지 저장 또는 정기 분석 트리거
    ↓
최근 N일간 대화 데이터 조회
    ↓
3종 분석기 병렬 실행
    ├─ 감정 패턴 분석 (부정 감정 비율/연속성)
    ├─ 무응답 패턴 분석 (응답률/무응답 연속성)
    └─ 키워드 감지 (긴급/경고 키워드)
    ↓
위험도 판정 (EMERGENCY/HIGH/MEDIUM/LOW)
    ↓
이상징후 감지 시
    ├─ AlertHistory 저장
    ├─ 보호자 목록 조회
    └─ 알림 발송
    ↓
알림 이력 저장
```

각 분석기는 독립적으로 동작하며, 하나의 분석기에서 이상징후가 감지되면 즉시 보호자에게 알림이 발송된다. 이를 통해 노인의 건강 이상을 조기에 발견하고 적절한 조치를 취할 수 있다.

### X-3-3. 안부 메시지 스케줄링

#### 기능 개요

안부 메시지 스케줄링 시스템은 매일 정해진 시간에 자동으로 안부 메시지를 발송하여 노인 사용자의 일상적인 소통을 유도한다. 주요 기능은 다음과 같다:

1. **정시 자동 발송**: Spring Scheduler의 Cron 표현식을 사용하여 매일 오전 9시(KST)에 모든 활성 회원에게 안부 메시지를 발송한다.

2. **메시지 다양화**: 요일별(7종) × 계절별(4종) 조합으로 500개 이상의 다양한 메시지를 생성한다. 이를 통해 사용자가 반복적인 메시지에 지루함을 느끼지 않도록 한다.

3. **중복 발송 방지**: 데이터베이스의 UNIQUE 제약 조건(`memberId`, `checkDate`)을 활용하여 동일 날짜에 중복 발송을 원천적으로 차단한다.

4. **자동 재시도**: 발송 실패 시 재시도 레코드를 생성하고, 5분 간격으로 최대 3회까지 재시도한다. 재시도 간격은 점진적으로 증가한다(5분, 10분, 15분).

#### 실행 화면

```
[그림 X-4] 스케줄링 시스템 로그 및 발송 이력
(추후 스크린샷 추가 예정)
```

시스템 로그를 통해 매일 오전 9시에 스케줄러가 트리거되고, 각 회원에게 메시지가 발송되는 과정을 확인할 수 있다. 발송 성공/실패 여부는 `DailyCheckRecord` 테이블에 기록된다.

#### 핵심 구현 코드

```java
/**
 * 스케줄링 트리거
 */
@Component
@RequiredArgsConstructor
@Slf4j
public class DailyCheckScheduler {

    private final DailyCheckOrchestrator dailyCheckOrchestrator;

    /**
     * 매일 안부 메시지 발송 트리거
     * Cron: 0 0 0 * * * (UTC 자정 = KST 오전 9시)
     */
    @Scheduled(cron = "${maruni.scheduling.daily-check.cron}")
    public void triggerDailyCheck() {
        log.info("Daily check triggered by scheduler");
        dailyCheckOrchestrator.processAllActiveMembers();
    }

    /**
     * 재시도 프로세스 트리거
     * Cron: 0 */5 * * * * (5분마다)
     */
    @Scheduled(cron = "${maruni.scheduling.retry.cron}")
    public void triggerRetryProcess() {
        log.info("Retry process triggered by scheduler");
        dailyCheckOrchestrator.processAllRetries();
    }
}
```

`DailyCheckOrchestrator`는 비즈니스 로직을 담당한다:

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class DailyCheckOrchestrator {

    private final MemberRepository memberRepository;
    private final DailyCheckMessageProvider messageProvider;
    private final NotificationHistoryService notificationHistoryService;
    private final ConversationService conversationService;
    private final RetryService retryService;

    /**
     * 전체 활성 회원 안부 메시지 발송
     */
    @Transactional
    public void processAllActiveMembers() {
        List<Long> activeMemberIds = memberRepository.findActiveMemberIds();
        log.info("Processing daily check for {} active members", activeMemberIds.size());

        activeMemberIds.forEach(this::processSingleMember);
    }

    private void processSingleMember(Long memberId) {
        // 1. 중복 발송 방지
        if (isAlreadySentToday(memberId)) {
            log.debug("Already sent today for member {}", memberId);
            return;
        }

        // 2. 메시지 생성 (요일 + 계절 반영)
        String message = messageProvider.generateMessage();

        // 3. 알림 발송 시도
        NotificationHistory result = notificationHistoryService.recordNotificationWithType(
            memberId,
            "안부 메시지",
            message,
            NotificationType.DAILY_CHECK,
            NotificationSourceType.DAILY_CHECK,
            null
        );

        // 4. 성공/실패 처리
        if (result != null) {
            handleSuccessfulSending(memberId, message);
        } else {
            handleFailedSending(memberId, message);
        }
    }

    private void handleFailedSending(Long memberId, String message) {
        log.warn("Failed to send daily check to member {}, scheduling retry", memberId);
        retryService.scheduleRetry(memberId, message);
    }
}
```

메시지 생성은 `DailyCheckMessageProvider`가 담당한다:

```java
@Component
public class DailyCheckMessageProvider {

    private static final Map<DayOfWeek, List<String>> WEEKDAY_MESSAGES = Map.of(
        DayOfWeek.MONDAY, List.of("월요일 아침입니다. {season} 날씨는 어떤가요?", ...),
        DayOfWeek.TUESDAY, List.of("화요일입니다. 오늘 하루도 건강하게 보내세요!", ...),
        // ... 요일별 메시지 정의
    );

    private static final Map<SeasonType, String> SEASON_NAMES = Map.of(
        SeasonType.SPRING, "봄",
        SeasonType.SUMMER, "여름",
        SeasonType.AUTUMN, "가을",
        SeasonType.WINTER, "겨울"
    );

    public String generateMessage() {
        LocalDate today = LocalDate.now();
        return generateMessage(today);
    }

    public String generateMessage(LocalDate date) {
        DayOfWeek dayOfWeek = date.getDayOfWeek();
        SeasonType season = SeasonType.fromMonth(date.getMonthValue());

        List<String> templates = WEEKDAY_MESSAGES.get(dayOfWeek);
        String template = selectTemplate(templates, date);

        // 계절 플레이스홀더 치환
        return template.replace("{season}", SEASON_NAMES.get(season));
    }

    private String selectTemplate(List<String> templates, LocalDate date) {
        long seed = date.toEpochDay();
        Random random = new Random(seed);
        int index = random.nextInt(templates.size());
        return templates.get(index);
    }
}
```

#### 동작 설명

전체 처리 흐름은 다음과 같다:

```
매일 00:00 UTC (KST 09:00) Cron 트리거
    ↓
활성 회원 목록 조회
    ↓
각 회원에 대해 순차 처리
    ├─ 오늘 발송 이력 확인 (중복 방지)
    ├─ 요일 + 계절 기반 메시지 생성
    ├─ 알림 발송 시도
    └─ 성공 시: DailyCheckRecord 저장
        실패 시: RetryRecord 생성
    ↓
5분마다 재시도 Cron 트리거
    ↓
재시도 대상 조회 (completed = false, scheduledTime <= now)
    ↓
재시도 실행 (최대 3회)
    ├─ 성공 시: RetryRecord 완료 처리
    └─ 실패 시: 재시도 횟수 증가, 다음 시도 시간 계산
```

메시지 생성 시 날짜를 시드로 사용하는 의사 난수 생성기를 활용하여, 동일 날짜에는 항상 같은 메시지가 선택되도록 결정적 동작을 보장한다. 이를 통해 테스트 가능성을 확보하면서도 날짜별로 다양한 메시지를 제공한다.

### X-3-4. 알림 시스템

#### 기능 개요

알림 시스템은 다양한 이벤트를 타입별로 분류하여 사용자에게 전달하고, 모든 알림의 이력을 관리한다. 주요 기능은 다음과 같다:

1. **알림 타입 분류**: 9종의 알림 타입(DAILY_CHECK, GUARDIAN_REQUEST, GUARDIAN_ACCEPT, GUARDIAN_REJECT, EMOTION_ALERT, NO_RESPONSE_ALERT, KEYWORD_ALERT, SYSTEM, CHAT)을 정의하여 알림의 성격을 명확히 구분한다.

2. **알림 출처 추적**: 5종의 출처 타입(DAILY_CHECK, ALERT_RULE, GUARDIAN_REQUEST, SYSTEM, CHAT)과 출처 엔티티 ID를 함께 저장하여 알림의 발생 원인을 추적할 수 있다.

3. **알림 이력 관리**: 모든 알림은 `NotificationHistory` 엔티티로 영속화되며, 발송 성공 여부, 발송 시각, 읽음 여부 등의 메타데이터를 포함한다.

4. **읽음 상태 관리**: 사용자가 알림을 확인하면 읽음 상태로 변경하고, 읽은 시각을 기록한다. 안읽은 알림 개수를 조회하여 UI 배지를 표시할 수 있다.

#### 실행 화면

```
[그림 X-5] 알림 이력 조회 API 응답
(추후 스크린샷 추가 예정)
```

사용자는 `/api/notifications` 엔드포인트를 통해 자신의 알림 이력을 조회할 수 있다. 응답에는 알림 타입, 제목, 내용, 발송 시각, 읽음 여부 등이 포함된다.

#### 핵심 구현 코드

알림 이력 저장은 `NotificationHistoryService`가 담당한다:

```java
public interface NotificationHistoryService {

    /**
     * 타입 정보를 포함한 알림 이력 저장
     *
     * @param memberId 알림 대상 회원 ID
     * @param title 알림 제목
     * @param message 알림 내용
     * @param notificationType 알림 타입 (9종)
     * @param sourceType 알림 출처 타입 (5종)
     * @param sourceEntityId 출처 엔티티 ID
     * @return 저장된 알림 이력
     */
    NotificationHistory recordNotificationWithType(
        Long memberId,
        String title,
        String message,
        NotificationType notificationType,
        NotificationSourceType sourceType,
        Long sourceEntityId
    );
}
```

구현체는 다음과 같다:

```java
@Service
@RequiredArgsConstructor
@Slf4j
public class NotificationHistoryServiceImpl implements NotificationHistoryService {

    private final NotificationHistoryRepository notificationHistoryRepository;

    @Override
    @Transactional
    public NotificationHistory recordNotificationWithType(
        Long memberId,
        String title,
        String message,
        NotificationType notificationType,
        NotificationSourceType sourceType,
        Long sourceEntityId
    ) {
        // 입력 검증
        validateNotificationInput(memberId, title, message);

        // NotificationHistory 엔티티 생성
        NotificationHistory notification = NotificationHistory.builder()
            .memberId(memberId)
            .title(title)
            .message(message)
            .notificationType(notificationType)
            .sourceType(sourceType)
            .sourceEntityId(sourceEntityId)
            .channelType(NotificationChannelType.PUSH)
            .success(true)
            .isRead(false)
            .build();

        // 영속화
        NotificationHistory saved = notificationHistoryRepository.save(notification);
        log.info("Notification history recorded: type={}, member={}, id={}",
            notificationType, memberId, saved.getId());

        return saved;
    }
}
```

알림 조회 및 읽음 처리는 `NotificationQueryService`가 담당한다:

```java
@Service
@RequiredArgsConstructor
@Transactional(readOnly = true)
public class NotificationQueryService {

    private final NotificationHistoryRepository notificationHistoryRepository;

    /**
     * 안읽은 알림 개수 조회
     */
    public int getUnreadNotificationCount(Long memberId) {
        return notificationHistoryRepository.countByMemberIdAndIsReadFalse(memberId);
    }

    /**
     * 알림 이력 조회 (최신순)
     */
    public List<NotificationHistoryResponseDto> getNotificationHistory(Long memberId) {
        List<NotificationHistory> histories = notificationHistoryRepository
            .findByMemberIdOrderByCreatedAtDesc(memberId);

        return histories.stream()
            .map(this::toResponseDto)
            .collect(Collectors.toList());
    }

    /**
     * 알림 읽음 처리
     */
    @Transactional
    public void markAsRead(Long notificationId, Long memberId) {
        NotificationHistory notification = notificationHistoryRepository
            .findById(notificationId)
            .orElseThrow(() -> new NotFoundException("알림을 찾을 수 없습니다"));

        // 권한 검증
        if (!notification.getMemberId().equals(memberId)) {
            throw new UnauthorizedException("본인의 알림만 읽음 처리할 수 있습니다");
        }

        notification.markAsRead();
        log.info("Notification marked as read: id={}, member={}", notificationId, memberId);
    }
}
```

`NotificationHistory` 엔티티는 다음과 같이 정의된다:

```java
@Entity
@Table(name = "notification_history")
@Getter
@NoArgsConstructor(access = AccessLevel.PROTECTED)
public class NotificationHistory extends BaseTimeEntity {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;

    @Column(nullable = false)
    private Long memberId;

    @Column(nullable = false)
    private String title;

    @Column(nullable = false, columnDefinition = "TEXT")
    private String message;

    @Enumerated(EnumType.STRING)
    @Column(name = "notification_type", nullable = false)
    private NotificationType notificationType;

    @Enumerated(EnumType.STRING)
    @Column(name = "source_type", nullable = false)
    private NotificationSourceType sourceType;

    @Column(name = "source_entity_id")
    private Long sourceEntityId;

    @Enumerated(EnumType.STRING)
    @Column(nullable = false)
    private NotificationChannelType channelType;

    @Column(nullable = false)
    private Boolean success;

    @Column(name = "is_read", nullable = false)
    private Boolean isRead = false;

    @Column(name = "read_at")
    private LocalDateTime readAt;

    public void markAsRead() {
        this.isRead = true;
        this.readAt = LocalDateTime.now();
    }
}
```

#### 동작 설명

전체 처리 흐름은 다음과 같다:

```
각 도메인에서 알림 이벤트 발생
    ├─ DailyCheck: 안부 메시지 발송
    ├─ AlertRule: 이상징후 감지
    ├─ Guardian: 보호자 요청/승인/거절
    └─ 기타: 시스템 알림, 대화 알림
    ↓
NotificationHistoryService.recordNotificationWithType() 호출
    ├─ 알림 타입 지정 (9종 중 선택)
    ├─ 출처 타입 지정 (5종 중 선택)
    ├─ 출처 엔티티 ID 지정
    └─ 메타데이터 설정 (발송 시각, 읽음 상태 등)
    ↓
NotificationHistory 엔티티 영속화
    ↓
사용자 조회 시
    ├─ 타입별 필터링 가능
    ├─ 읽음/안읽음 필터링 가능
    └─ 출처 엔티티 추적 가능
    ↓
읽음 처리 시
    ├─ isRead = true
    └─ readAt = 현재 시각
```

알림 시스템은 각 도메인과 느슨하게 결합되어 있어, 새로운 알림 타입 추가가 용이하다. 또한 모든 알림 이력이 영속화되므로, 추후 통계 분석이나 사용자 행동 분석에 활용할 수 있다.

---

## 결론

본 장에서는 MARUNI 시스템의 개발 환경, 주요 구현 기능, 그리고 핵심 기능의 상세 구현 결과를 기술하였다. 시스템은 DDD 아키텍처와 TDD 방법론을 기반으로 개발되었으며, OpenAI GPT-4o를 활용한 자연어 대화, 3종 알고리즘 기반 이상징후 감지, 스케줄링 기반 안부 메시지 발송, 타입 분류 알림 시스템 등의 핵심 기능을 구현하였다.

각 기능은 독립적인 도메인으로 설계되어 유지보수성과 확장성을 보장하며, REST API를 통해 클라이언트와 통신한다. 전체 시스템은 Docker를 통해 컨테이너화되어 일관된 개발 및 배포 환경을 제공한다.
